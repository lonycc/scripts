# Linux系统启动过程

> 内核的引导-》运行init-》系统初始化-》建立终端-》用户登录系统

## 内核引导

> 计算机加电，BIOS开机自检，按照BIOS中设置的启动设备来启动。操作系统接管硬件以后，首先读入/boot目录下的内核文件。

## 运行init

> init进程是系统所有进程的起点，init程序首先需要读取文件/etc/inittab

**运行级别**

> 开机启动程序，称为守护进程daemon，init进程的一大任务，就是去运行这些开机启动的程序。linux允许为不同的场合，分配不同的开机启动程序，这就叫“运行级别”。

7个运行级别

- 0: 系统停机状态，不能设为0，否则不能正常启动

- 1: 单用户工作状态，root权限，用于系统维护，禁止远程登陆

- 2: 多用户状态(没有NFS)

- 3: 完全的多用户状态(有NFS)，登陆后进入控制台命令行模式，默认模式

- 4: 保留

- 5: X11控制台，登陆后进入图形GUI模式

- 6: 系统正常关闭并重启, 不能设为6, 否则不能正常启动

## 系统初始化

> 在init的配置文件中有这么一行: si::sysinit:/etc/rc.d/rc.sysinit 它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell脚本。

> 它主要完成一些系统初始化工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。

> 它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。

> l5:5:wait:/etc/rc.d/rc 5 #以5为参数执行rc5.d目录下所有rc启动脚本。rc5.d目录中这些启动脚本实际上都是一些连接文件，而真正的rc启动脚本在init.d目录下。

> rc5.d目录下以K开始的连接文件，而且已经处于运行态(/var/locak/subsys/下的文件标志)，则首先以stop为参数停止这些守护进程，再重新运行。

> 以S开始的连接文件，以start参数来运行。

## 建立终端

> rc执行完毕后，返回init，这是基本系统环境已经设置好了，各种守护进程业也已经启动了。

> init接下来会打开6个终端，以便用户登陆系统，在inittab中的6行定义了6个终端。

> 1:2345respawn:/sbin/mingetty tty1

> 2345运行级别都以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。

> 同时它会显示一个文本登录界面，这个界面就是登陆界面。

## 用户登录系统

> 命令行登录、ssh登录、图形界面登录

> /etc/nologin  存在此文件，login将输出nologin文件的内容，然后退出

> /etc/securetty   只有此文件中登记了的终端才允许root用户登录

> /etc/usertty  

<br/><br/>

# Linux关机

> sync > shutdown > reboot > halt

> sync将数据由内存同步到硬盘

> shutdown -h now/halt/poweroff/init 0 关机

> reboot/init 6/shutdown -r now 重启

<br/><br/>

# 编译器工作过程

> 编译器的任务，是将源码转为二进制的机器码。

`gcc test.c`

`./a.out`

对于复杂的项目，编译过程分成三步：

`./configure`

`make`

`make install`

下面以gcc编译器为例介绍其工作过程

![gcc编译过程](compile.png)

## 第一步 配置(configure)

> 指定编译参数的过程，如标准库路径，安装路径，支持组件等。

> 配置信息保存在一个配置文件中，这个文件叫configure脚本文件。通常它由autoconf工具生成。

> 编译器通过运行configure脚本，获知编译参数。

## 第二步 确定标准库和头文件的位置

> 源码用到标准库函数和头文件，编译器没法自动检测到它们的位置，只能通过配置文件获取。

> 一般配置文件会给出一个清单，列出几个具体的目录，等到编译时，编译器就按顺序到这几个目录中寻找目标。

## 第三步 确定依赖关系

> 对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖B文件，则编译器应该保证做到下面两点：
  
- (1) 只有B文件编译完成后，才开始编译A文件

- (2) 当B文件发生变化时，A文件会重新编译

> 编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成。

## 第四步 头文件的预编译(precompilation)

> 不同的源码文件，可能引用同一个头文件。编译的时候，头文件也必须一起编译。为了节省时间，编译器在

> 编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译。

> 不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。

## 第五步 预处理(preprocessing)

> 预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。编译器还会移除注释。

## 第六步  编译(Compilation)

> 预处理之后，编译器开始生成机器码。对某些编译器来说，还存在一个中间步骤，先把源码转为汇编码Assembly，然后再把汇编码转为机器码。转码后的文件称为对象文件。

## 第七步  连接(Linking)

> 对象文件还不能运行，必须进一步转成可执行文件。编译器的下一步工作，就是把外部函数的代码(.lib和.a文件)添加到可执行文件中，这就叫做连接。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接(static linking)。

> make命令的作用，就是从第四步到第七步。

## 第八步  安装(Installation)

> 上一步的连接实在内存中进行的，即编译器在内存中生成了可执行文件。下一步，必须将可执行文件保存到用户指定的安装目录中。表面上，这一步很简单，就是将可执行文件（连带相关的数据文件）拷贝过去就行了。但是实际上，这一步还必须完成创建目录、保存文件、设置权限等步骤。这整个的保存过程就称为"安装"（Installation）。

## 第九步  操作系统连接
> 可执行文件安装后，必须以某种方式通知操作系统，让其知道可以使用这个程序了。比如，我们安装了一个文本阅读程序，往往希望双击txt文件，该程序就会自动运行。

> 这就要求在操作系统中，登记这个程序的元数据：文件名、文件描述、关联后缀名等等。Linux系统中，这些信息通常保存在/usr/share/applications目录下的.desktop文件中。另外，在Windows操作系统中，还需要在Start启动菜单中，建立一个快捷方式。

> 这些事情就叫做"操作系统连接"。make install命令，就用来完成"安装"和"操作系统连接"这两步。

## 第十步  生成安装包

## 第十一步  动态连接(dynamic linking)

> 编译阶段选择可执行文件连接外部函数库的方式，静态连接（编译时连接），动态连接（运行时连接）。

> 静态连接好处是适用范围广，不用担心机器缺少某个库文件；缺点是安装包比较大，无法在多个应用程序之间共享库文件。

> 动态连接好处是安装包小，共享库文件；缺点是必须事先装好库文件，并且对版本和路径有要求。

> 在linux中共享库是.so文件，windows里是.dll文件。
